{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf16 #include <vector>
\par #include <string.h>
\par #include <string>
\par #include <fstream>
\par #include <cstdlib>
\par #include <unistd.h>
\par #include <algorithm>
\par #include <stdlib.h>
\par #include <stdio.h>
\par #include <iostream>
\par #include <cctype>
\par #include <cstring>
\par #include <ctime> \cb3\cf4 //Para manejar tiempo
\par \cb3\cf16 #define MAX 90000
\par \cb3\cf4 //Estructura de datos ll
\par //Primera practica
\par //Miembros:
\par //Angel Liu Sanchez
\par //Barragan Gonzalez Carlos Ivan
\par //Diego Rafael Maldonado Mendoza
\par 
\par \cb3\cf14\b using namespace \b0\cb3\cf16\b std\b0\cb3\cf25 ;
\par \cb3\cf14\b using \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 stoi\cb3\cf25 ;\cb3\cf4 //libreria para poder usar la funcion stoi
\par \cb3\cf16\b string \b0\cb1\cf0 aux\cb3\cf25 , \cb1\cf0 aux2\cb3\cf25 ;
\par 
\par \cb3\cf14\b struct \b0\cb1\cf0 Menu
\par \cb3\cf25 \{ \cb3\cf4 //estructura de menu, el cual llevara los campos de menu.
\par     \cb3\cf14\b int \b0\cb1\cf0 indice\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 7\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 especialidad\cb3\cf25 [\cb3\cf12 18\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 25\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 descripcion\cb3\cf25 [\cb3\cf12 180\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 precio\cb3\cf25 [\cb3\cf12 9\cb3\cf25 ];
\par 
\par     \cb3\cf14\b void \b0\cb1\cf0 Ingresar\cb3\cf25 ();\cb3\cf4 //funcion para ingresar datos en el archivo
\par     \cb3\cf14\b void \b0\cb1\cf0 Ordenamiento\cb3\cf25 ();\cb3\cf4 //funcion para ordenar el indice
\par     \cb3\cf14\b void \b0\cb1\cf0 Buscar\cb3\cf25 ();\cb3\cf4 //funcion para buscar
\par \cb3\cf25 \}\cb1\cf0 me\cb3\cf25 ;
\par 
\par \cb3\cf14\b struct \b0\cb1\cf0 stIndicecodi
\par \cb3\cf25 \{ \cb3\cf4 //estructura de indice, el cual llevara la llave primaria (codigo) y el nnr (indice).
\par     \cb3\cf14\b char \b0\cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 7\cb3\cf25 ];
\par     \cb3\cf14\b int \b0\cb1\cf0 indice \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par \}\cb1\cf0 in\cb3\cf25 ;
\par 
\par 
\par \cb3\cf16\b string \b0\cb1\cf0 Rellenar\cb3\cf25 (\cb3\cf16\b string \b0\cb1\cf0 dato\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 t\cb3\cf25 )
\par \{ \cb3\cf4 //funcion para rellenar espacios
\par     \cb1\cf0 aux \cb3\cf25 = \cb3\cf20 ""\cb3\cf25 ;
\par     \cb1\cf0 aux2 \cb3\cf25 = \cb3\cf20 ""\cb3\cf25 ; \cb3\cf4 //aux3 = "";
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 t\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++)
\par     \{ \cb3\cf4 //ponemos en bucle el array
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 <\cb1\cf0 dato\cb3\cf25 .\cb1\cf0 length\cb3\cf25 ())
\par         \{ \cb3\cf4 // sacamos el tamaï¿½o de los datos
\par             \cb1\cf0 aux\cb3\cf25 .\cb3\cf16\b insert\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 , \cb1\cf0 dato\cb3\cf25 .\cb3\cf16\b substr\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 ,\cb3\cf12 1\cb3\cf25 ));\cb3\cf4 //en un auxiliar mandamos lo que esta existente en el array para no perder el dato
\par         \cb3\cf25 \}
\par         \cb3\cf14\b else
\par         \b0\cb3\cf25 \{
\par             \cb1\cf0 aux\cb3\cf25 .\cb3\cf16\b insert\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 , \cb3\cf20 " "\cb3\cf25 );\cb3\cf4 //rellena con espacios el resto de bits disponibles.
\par         \cb3\cf25 \}
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 aux\cb3\cf25 ;\cb3\cf4 // retorna el auxiliar con los espacios utilisados
\par     \cb1\cf0 dato\cb3\cf25 =\cb3\cf20 ""\cb3\cf25 ;
\par     \cb1\cf0 t\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Menu\cb3\cf25 ::\cb1\cf0 Ingresar\cb3\cf25 ()
\par \{ \cb3\cf4 //funcion para ingresar datos
\par     //indice method
\par     // indice+=1;
\par     \cb3\cf16\b string \b0\cb1\cf0 texto\cb3\cf25 ;
\par     \cb3\cf14\b int \b0\cb1\cf0 j\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ;
\par 
\par     \cb3\cf16\b ifstream \b0\cb1\cf0 archivo\cb3\cf25 ;\cb3\cf4 //abrirmos el archivo en modo lectura
\par     \cb1\cf0 archivo\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb3\cf20 "MENU.txt"\cb3\cf25 ,\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ios\cb3\cf25 ::\cb1\cf0 app\cb3\cf25 );
\par     \cb3\cf14\b while\b0\cb3\cf25 (!\cb1\cf0 archivo\cb3\cf25 .\cb1\cf0 eof\cb3\cf25 ())
\par     \{
\par         \cb1\cf0 getline\cb3\cf25 (\cb1\cf0 archivo\cb3\cf25 ,\cb1\cf0 texto\cb3\cf25 );
\par         \cb1\cf0 j\cb3\cf25 +=\cb3\cf12 1\cb3\cf25 ;
\par     \}
\par     \cb1\cf0 archivo\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 //ceramos el archivo
\par     \cb1\cf0 indice\cb3\cf25 =\cb1\cf0 j\cb3\cf25 ;\cb3\cf4 //pasamos j a indice
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ofstream \b0\cb1\cf0 archivomenu\cb3\cf25 ;\cb3\cf4 //abrimos el archivo en modo escritura
\par     \cb1\cf0 archivomenu\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb3\cf20 "MENU.txt"\cb3\cf25 ,\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ios\cb3\cf25 ::\cb1\cf0 app\cb3\cf25 ); \cb3\cf4 //Abriendo y creando archivo
\par     \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 indice \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ;\cb3\cf4 //se escribe el indice
\par     \cb3\cf14\b char \b0\cb1\cf0 random\cb3\cf25 [\cb3\cf12 10\cb3\cf25 ]= \{\cb3\cf22 '0'\cb3\cf25 ,\cb3\cf22 '1'\cb3\cf25 ,\cb3\cf22 '2'\cb3\cf25 ,\cb3\cf22 '3'\cb3\cf25 ,\cb3\cf22 '4'\cb3\cf25 ,\cb3\cf22 '5'\cb3\cf25 ,\cb3\cf22 '6'\cb3\cf25 ,\cb3\cf22 '7'\cb3\cf25 ,\cb3\cf22 '8'\cb3\cf25 ,\cb3\cf22 '9'\cb3\cf25 \};\cb3\cf4 //cadena de numeros a tomar aleatoreamente para la llave canonica
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par     \cb3\cf4 //Forma Canonica
\par     //Dos bits [0:1]
\par     \cb1\cf0 srand \cb3\cf25 ( \cb1\cf0 time\cb3\cf25 (\cb1\cf0 NULL\cb3\cf25 ) ); \cb3\cf4 // Tomar time como referencia para generar diferente NRG
\par     \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] = \cb1\cf0 random\cb3\cf25 [\cb1\cf0 rand\cb3\cf25 ()%\cb3\cf12 10\cb3\cf25 ];\cb3\cf4 //tomamos el cero byte del codigo y le aplicamos rand con nuestra cadeba ya hecha
\par     \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ] = \cb1\cf0 random\cb3\cf25 [\cb1\cf0 rand\cb3\cf25 ()%\cb3\cf12 10\cb3\cf25 ];\cb3\cf4 //tomamos el primero byte del codigo y le aplicamos rand con nuestra cadena ya hecha
\par     //Dos bits [1:2|3]
\par     \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\tDame el nombre de la especialidad: " \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par     \cb3\cf16\b cin\b0\cb3\cf25 .\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 ,\cb3\cf12 18\cb3\cf25 );\cb3\cf4 //entra el nombre de la especialidad
\par     \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 ;
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 <=\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 ); \cb1\cf0 i\cb3\cf25 ++)
\par     \{ \cb3\cf4 // pone en mayusculas la especialidad
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]>=\cb3\cf12 97 \cb3\cf25 && \cb1\cf0 especialidad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]<=\cb3\cf12 122\cb3\cf25 )
\par         \{
\par             \cb1\cf0 especialidad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]=\cb1\cf0 especialidad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]-\cb3\cf12 32\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 ,\cb3\cf12 18\cb3\cf25 );\cb3\cf4 //rellena con espacios, los espacios vacios
\par     \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 //aux2 se escribe en especialidad
\par     \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 especialidad \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ;\cb3\cf4 // especialidad se escibe al archivo "MENU.txt"
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 ); \cb3\cf4 /////////////////
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 aux2 \cb3\cf25 == \cb3\cf20 "PICAR Y COMPARTIR "\cb3\cf25 )
\par     \{\cb3\cf4 //if para seguir la forma canonica
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ]=\cb1\cf0 especialidad\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];\cb3\cf4 //tomamos el cero byte de especialidad y lo insertamos en el codigo en el byte 2
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 3\cb3\cf25 ]=\cb1\cf0 especialidad\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];\cb3\cf4 //tomamos el primer byte de especialidad y lo insertamos en el codigo en el byte 3
\par         \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par         \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 18\cb3\cf25 );\cb3\cf4 //limpia para no unirlo con basura
\par         \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\tDame el nombre: " \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \cb3\cf16\b cin\b0\cb3\cf25 .\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb3\cf12 25\cb3\cf25 );\cb3\cf4 //recibe el nombre
\par         \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 ;
\par         \cb3\cf14\b for\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 <=\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ); \cb1\cf0 i\cb3\cf25 ++)
\par         \{ \cb3\cf4 //pone en mayusculas el nombre
\par             \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]>=\cb3\cf12 97 \cb3\cf25 && \cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]<=\cb3\cf12 122\cb3\cf25 )
\par             \{
\par                 \cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]=\cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]-\cb3\cf12 32\cb3\cf25 ;
\par             \}
\par         \}
\par         \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb3\cf12 25\cb3\cf25 );\cb3\cf4 //rellena con espacios, los espacios vacios en nombre
\par         \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 //aux2 se escribe en nombre
\par         \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 nombre \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ;\cb3\cf4 //nombre se escribe en el archivo "MENU.txt"
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 4\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];\cb3\cf4 //codigo toma el 4 bit de codigo y le asigna el primer bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 5\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];\cb3\cf4 //codigo toma el 5 bit de codigo y le asigna el segundo bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 6\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ];\cb3\cf4 //codigo toma el 6 bit de codigo y le asigna el tercero bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 25\cb3\cf25 );\cb3\cf4 //limpia para no unirlo con la basura
\par     \cb3\cf25 \}
\par     \cb3\cf14\b else
\par     \b0\cb3\cf25 \{
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ]=\cb1\cf0 especialidad\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];\cb3\cf4 //codigo toma el 0 bit de especialida y le asigna el segundo bit siguiendo la forma canonica
\par         \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par         \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 18\cb3\cf25 );\cb3\cf4 //limpia para no unirlo con basura
\par         \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\tDame el nombre: " \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \cb3\cf16\b cin\b0\cb3\cf25 .\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb3\cf12 25\cb3\cf25 );\cb3\cf4 //recibe el nombre
\par         \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 ;
\par         \cb3\cf14\b for\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 <=\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ); \cb1\cf0 i\cb3\cf25 ++)
\par         \{ \cb3\cf4 //pone en mayusculas el nombre
\par             \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]>=\cb3\cf12 97 \cb3\cf25 && \cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]<=\cb3\cf12 122\cb3\cf25 )
\par             \{
\par                 \cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]=\cb1\cf0 nombre\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]-\cb3\cf12 32\cb3\cf25 ;
\par             \}
\par         \}
\par         \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb3\cf12 25\cb3\cf25 );\cb3\cf4 //rellena con espacios, los espcacios vacios en nombre
\par         \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 // aux2 se escribe en nombre
\par         \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 nombre \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ;\cb3\cf4 //nombre se escribe en el archvo "MENU.txt"
\par         \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 ); \cb3\cf4 ///////
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 3\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];\cb3\cf4 //codigo toma el 3 bit de codigo y le asigna el primer bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 4\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];\cb3\cf4 //codigo toma el 4 bit de codigo y le asigna el segundo bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 codigo\cb3\cf25 [\cb3\cf12 5\cb3\cf25 ] = \cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ];\cb3\cf4 //codigo toma el 5 bit de codigo y le asigna el tercero bit de nombre siguiendo la forma canonica
\par         \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 25\cb3\cf25 );\cb3\cf4 //limpia nombre para no unirlo con basura
\par     \cb3\cf25 \}
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par     \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\tDame la descripcion: " \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par     \cb3\cf16\b cin\b0\cb3\cf25 .\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 ,\cb3\cf12 180\cb3\cf25 );\cb3\cf4 //recibe descripcion
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 <=\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 ); \cb1\cf0 i\cb3\cf25 ++)
\par     \{ \cb3\cf4 //pone en mayusculas la descripcion
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]>=\cb3\cf12 97 \cb3\cf25 && \cb1\cf0 descripcion\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]<=\cb3\cf12 122\cb3\cf25 )
\par         \{
\par             \cb1\cf0 descripcion\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]=\cb1\cf0 descripcion\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]-\cb3\cf12 32\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 ,\cb3\cf12 180\cb3\cf25 );\cb3\cf4 //rellena de espacios, los espacios vacios de la descripcion
\par     \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 //aux2 se escribe en descripcion
\par     \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 descripcion \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ;\cb3\cf4 //escribe el campo descripcion en el archivo "MENU,txt"
\par     \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 codigo\cb3\cf25 ,\cb3\cf12 7\cb3\cf25 );\cb3\cf4 //rellena de espacios vacios codigo
\par     \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 codigo\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 //aux2 se escribe en codigo
\par     \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 codigo \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ; \cb3\cf4 // escribe el codigo con la forma canonica descripcion en el archivo "MENU,txt"
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 ); \cb3\cf4 /////////////////////////
\par     \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 180\cb3\cf25 );
\par     \cb3\cf4 //precio
\par     \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\tDame el precio: " \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par     \cb3\cf16\b cin\b0\cb3\cf25 .\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 precio\cb3\cf25 ,\cb3\cf12 9\cb3\cf25 );\cb3\cf4 //recibe precio
\par     \cb1\cf0 aux2 \cb3\cf25 = \cb1\cf0 Rellenar\cb3\cf25 (\cb1\cf0 precio\cb3\cf25 ,\cb3\cf12 9\cb3\cf25 );\cb3\cf4 //rellena de espacios vacios precio
\par     \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 precio\cb3\cf25 ,\cb1\cf0 aux2\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ());\cb3\cf4 //aux2 se escribe en precio
\par     \cb1\cf0 archivomenu \cb3\cf25 << \cb1\cf0 precio \cb3\cf25 << \cb3\cf20 "|" \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ;\cb3\cf4 //escribe el precio con la forma canonica descripcion en el archivo "MENU,txt"
\par     // cout<<"\\nCodigo: "<< codigo << "|" << endl;//imprime el codigo
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par     \cb1\cf0 archivomenu\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 //se cierra el archivo
\par 
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ofstream \b0\cb1\cf0 archivoindice\cb3\cf25 ;\cb3\cf4 // se abre el archivo "INDICE.TXT" en modo escritura
\par     \cb1\cf0 archivoindice\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb3\cf20 "INDICE.txt"\cb3\cf25 ,\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ios\cb3\cf25 ::\cb1\cf0 app\cb3\cf25 );
\par     \cb1\cf0 in\cb3\cf25 .\cb1\cf0 indice\cb3\cf25 =\cb1\cf0 indice\cb3\cf25 ;\cb3\cf4 //se mete indice en el indice del archivo "INIDICE.TXT" el cual va a ser el nrr
\par     \cb1\cf0 strcpy\cb3\cf25 (\cb1\cf0 in\cb3\cf25 .\cb1\cf0 codigo\cb3\cf25 ,\cb1\cf0 codigo\cb3\cf25 );\cb3\cf4 //se mete codigo a codgio del archivo "INDICE.TXT"
\par     \cb1\cf0 archivoindice \cb3\cf25 << \cb1\cf0 in\cb3\cf25 .\cb1\cf0 codigo \cb3\cf25 << \cb3\cf20 "|"\cb3\cf25 ; \cb3\cf4 //escribe codigo en el archivo "INDICE.TXT"
\par     \cb1\cf0 archivoindice \cb3\cf25 << \cb1\cf0 in\cb3\cf25 .\cb1\cf0 indice \cb3\cf25 << \cb3\cf16\b endl\b0\cb3\cf25 ; \cb3\cf4 //escribe indice o en este caso el nrr en el archivo "INDICE.TXT"
\par     \cb1\cf0 archivoindice\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 // se cierrra el nrr
\par 
\par     \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 codigo\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 7\cb3\cf25 );\cb3\cf4 //se limpia el codigo para que no lo una con basura
\par     \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 descripcion\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 180\cb3\cf25 );
\par     \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 25\cb3\cf25 );
\par     \cb1\cf0 memset\cb3\cf25 (\cb1\cf0 especialidad\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb3\cf12 18\cb3\cf25 );\cb3\cf4 //se limpian todos los datos para que no los una con basura
\par     \cb3\cf25 \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Menu\cb3\cf25 ::\cb1\cf0 Ordenamiento\cb3\cf25 ()
\par \{ \cb3\cf4 //funcion que ordena el indice
\par     \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 , \cb1\cf0 r\cb3\cf25 , \cb1\cf0 j\cb3\cf25 ;
\par     \cb3\cf16\b string \b0\cb1\cf0 aux1\cb3\cf25 ;
\par     \cb3\cf16\b vector \b0\cb3\cf25 <\cb3\cf16\b string\b0\cb3\cf25 > \cb1\cf0 v \cb3\cf25 (\cb1\cf0 MAX\cb3\cf25 );
\par     \cb3\cf16\b ifstream \b0\cb1\cf0 archivo1 \cb3\cf25 (\cb3\cf20 "INDICE.txt"\cb3\cf25 );\cb3\cf4 //se abre el archivo en modo de lectura
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 archivo1\cb3\cf25 .\cb1\cf0 fail\cb3\cf25 ()) \cb3\cf16\b cout\b0\cb3\cf25 <<\cb3\cf20 "El archivo no se abrio correctamente."\cb3\cf25 <<\cb3\cf16\b endl\b0\cb3\cf25 ;\cb3\cf4 //en caso de el archivo no se abrio correctamente
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 archivo1\cb3\cf25 , \cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]))
\par     \{ \cb3\cf4 //Guardamos las lineas en vector
\par         // cout << v[i] << endl;
\par         \cb1\cf0 i\cb3\cf25 ++;
\par     \}
\par     \cb1\cf0 archivo1\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par     \cb3\cf4 //Ordenamiento de Codigo
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 <\cb1\cf0 indice\cb3\cf25 -\cb3\cf12 1\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++)
\par     \{ \cb3\cf4 //forma de ordenamiento de bubblesort
\par         \cb3\cf14\b for\b0\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 j\cb3\cf25 =\cb1\cf0 i\cb3\cf25 +\cb3\cf12 1\cb3\cf25 ; \cb1\cf0 j\cb3\cf25 <\cb1\cf0 indice\cb3\cf25 ; \cb1\cf0 j\cb3\cf25 ++)
\par         \{
\par             \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]>\cb1\cf0 v\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ])
\par             \{
\par                 \cb1\cf0 aux1 \cb3\cf25 = \cb1\cf0 v\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ];
\par                 \cb1\cf0 v\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ] = \cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par                 \cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] = \cb1\cf0 aux1\cb3\cf25 ;
\par             \}
\par         \}
\par     \}
\par     \cb3\cf4 // std::cout << "\\nORDENADA: " << '\\n';
\par     //Impresion de Ordenamiento
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ofstream \b0\cb1\cf0 archivo2\cb3\cf25 ;\cb3\cf4 // se abre el archivo en escritura
\par     \cb1\cf0 archivo2\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb3\cf20 "INDICE.txt"\cb3\cf25 ,\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ios\cb3\cf25 ::\cb1\cf0 ate\cb3\cf25 ); \cb3\cf4 // Abrir archivo en modo ios:ate para sobreescribir
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 = \cb3\cf12 0 \cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 indice \cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++)
\par     \{
\par         \cb1\cf0 archivo2 \cb3\cf25 << \cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] << \cb3\cf16\b endl\b0\cb3\cf25 ;
\par     \}
\par     \cb1\cf0 archivo2\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 //se cierra el archivo
\par 
\par     // std::cout << "Funcion Ordenamiento" << '\\n';
\par     // sleep (1);
\par \cb3\cf25 \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Menu\cb3\cf25 ::\cb1\cf0 Buscar\cb3\cf25 ()
\par \{ \cb3\cf4 //funcion para buscar y recuperar el dato
\par     \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 , \cb1\cf0 r\cb3\cf25 , \cb1\cf0 j\cb3\cf25 , \cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 ia\cb3\cf25 =-\cb3\cf12 1\cb3\cf25 ;
\par     \cb3\cf16\b string \b0\cb1\cf0 aux1\cb3\cf25 , \cb1\cf0 aux2\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "Dame el codigo a buscar: " \cb3\cf25 << \cb3\cf22 '\\n'\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cin \b0\cb3\cf25 >> \cb1\cf0 aux1\cb3\cf25 ;
\par     \cb3\cf16\b size\b0\cb3\cf25 =\cb1\cf0 aux1\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 ();\cb3\cf4 //saca el tamaño de aux1
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b transform\b0\cb3\cf25 (\cb1\cf0 aux1\cb3\cf25 .\cb3\cf16\b begin\b0\cb3\cf25 (), \cb1\cf0 aux1\cb3\cf25 .\cb3\cf16\b end\b0\cb3\cf25 (), \cb1\cf0 aux1\cb3\cf25 .\cb3\cf16\b begin\b0\cb3\cf25 (), ::\cb1\cf0 toupper\cb3\cf25 );\cb3\cf4 //pone todo en mayusculas
\par     \cb3\cf16\b vector \b0\cb3\cf25 <\cb3\cf16\b string\b0\cb3\cf25 > \cb1\cf0 v \cb3\cf25 (\cb1\cf0 MAX\cb3\cf25 );
\par     \cb3\cf16\b ifstream \b0\cb1\cf0 archivo1 \cb3\cf25 (\cb3\cf20 "INDICE.txt"\cb3\cf25 );\cb3\cf4 //abre el archivo en modo lectura
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 archivo1\cb3\cf25 .\cb1\cf0 fail\cb3\cf25 ()) \cb3\cf16\b cout\b0\cb3\cf25 <<\cb3\cf20 "El archivo no se abrio correctamente."\cb3\cf25 <<\cb3\cf16\b endl\b0\cb3\cf25 ;\cb3\cf4 // ver si el archivo falla
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 archivo1\cb3\cf25 , \cb1\cf0 v\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]))
\par     \{ \cb3\cf4 //Guardamos las lineas en vector
\par         \cb1\cf0 i\cb3\cf25 ++;
\par     \}
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b size_t \b0\cb1\cf0 j \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 j \cb3\cf25 < \cb1\cf0 i\cb3\cf25 ; \cb1\cf0 j\cb3\cf25 ++)
\par     \{\cb3\cf4 // for para comparar codigos
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 v\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ].\cb3\cf16\b substr\b0\cb3\cf25 (\cb3\cf12 0\cb3\cf25 ,\cb3\cf16\b size\b0\cb3\cf25 ) == \cb1\cf0 aux1\cb3\cf25 )
\par         \{\cb3\cf4 //compara el codigo con el auxiliar1
\par             \cb1\cf0 ia \cb3\cf25 = \cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 stoi\cb3\cf25 (\cb1\cf0 v\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ].\cb3\cf16\b substr\b0\cb3\cf25 (\cb3\cf12 8\cb3\cf25 ,\cb3\cf12 2\cb3\cf25 ));\cb3\cf4 //convierte a entero
\par         \cb3\cf25 \}
\par     \}
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 ia \cb3\cf25 == -\cb3\cf12 1\cb3\cf25 )
\par     \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "No hay match :C" \cb3\cf25 << \cb3\cf22 '\\n'\cb3\cf25 ;\cb3\cf4 // condicional por si no hay registro
\par     \cb3\cf25 \}
\par     \cb3\cf14\b else
\par     \b0\cb3\cf25 \{
\par         \cb1\cf0 i\cb3\cf25 =\cb3\cf12 0\cb3\cf25 ;
\par         \cb3\cf16\b vector \b0\cb3\cf25 <\cb3\cf16\b string\b0\cb3\cf25 > \cb1\cf0 recuperarNRR \cb3\cf25 (\cb1\cf0 MAX\cb3\cf25 );
\par         \cb3\cf16\b ifstream \b0\cb1\cf0 archi \cb3\cf25 (\cb3\cf20 "MENU.txt"\cb3\cf25 );\cb3\cf4 //abre el archivo en forma de lectura
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 archi\cb3\cf25 .\cb1\cf0 fail\cb3\cf25 ()) \cb3\cf16\b cout\b0\cb3\cf25 <<\cb3\cf20 "El archivo no se abrio correctamente."\cb3\cf25 <<\cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 getline\cb3\cf25 (\cb1\cf0 archi\cb3\cf25 , \cb1\cf0 recuperarNRR\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]))
\par         \{ \cb3\cf4 //Guardamos las lineas en vector
\par             \cb1\cf0 i\cb3\cf25 ++;
\par         \}
\par         \cb1\cf0 archi\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 //cerrarmos el archivo
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb1\cf0 recuperarNRR\cb3\cf25 [\cb1\cf0 ia\cb3\cf25 -\cb3\cf12 1\cb3\cf25 ] << \cb3\cf22 '\\n'\cb3\cf25 ;\cb3\cf4 //mostramos a pantalla el registro buscado
\par     \cb3\cf25 \}
\par     \cb1\cf0 archivo1\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();\cb3\cf4 //ceramos el archivo
\par \cb3\cf25 \}
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 main\cb3\cf25 () \{\cb3\cf4 // Menu del programa
\par     \cb3\cf14\b int \b0\cb1\cf0 opc\cb3\cf25 ;
\par 
\par     \cb3\cf14\b do \b0\cb3\cf25 \{
\par         \cb3\cf4 // system("clear");
\par         \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\t\\t\\t -->|BIENVENIDO A TELEPIZZA|<-- \\n\\n"\cb3\cf25 ;
\par         \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "    Selecciona una de la siguientes opciones:\\n\\n"\cb3\cf25 ;
\par         \cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "\\t(1).-Insertar registro\\n" \cb3\cf25 << \cb3\cf20 "\\t(2).-Mostrar un registro por su Codigo\\n" \cb3\cf25 << \cb3\cf20 "\\t(3).-Salir\\n\\n" \cb3\cf25 << \cb3\cf20 "-->"\cb3\cf25 ;
\par         \cb3\cf16\b cin \b0\cb3\cf25 >> \cb1\cf0 opc\cb3\cf25 ;
\par         \cb3\cf14\b switch\b0\cb3\cf25 (\cb1\cf0 opc\cb3\cf25 )
\par         \{ \cb3\cf4 //switch para entrar en cada uno de los casos del menu
\par             \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 :
\par                 \{
\par                     \cb3\cf4 // std::cout << "Opcion 1" << '\\n';
\par                     // sleep (1);
\par                     \cb1\cf0 me\cb3\cf25 .\cb1\cf0 Ingresar\cb3\cf25 ();\cb3\cf4 //manda a llamar la funcion ingresar
\par                     \cb1\cf0 me\cb3\cf25 .\cb1\cf0 Ordenamiento\cb3\cf25 ();\cb3\cf4 //manda a llamar la funcion ordenamiento
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \}
\par             \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 :
\par                 \{
\par                     \cb3\cf4 // std::cout << "Opcion 2" << '\\n';
\par                     \cb1\cf0 me\cb3\cf25 .\cb1\cf0 Buscar\cb3\cf25 ();\cb3\cf4 //manda a llamar la funcion de buscar
\par                     // sleep (1);
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \}
\par         \}
\par     \}
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 opc \cb3\cf25 != \cb3\cf12 3\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par     \}
\par }